package st.cri.app.service.service_impl

import org.apache.logging.log4j.LogManager
import org.springframework.data.domain.Page
import org.springframework.data.domain.PageRequest
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import st.cri.app.dao.UserDao
import st.cri.app.domain.user.RoleName
import st.cri.app.domain.user.User
import st.cri.app.dto.user.UserDTO
import st.cri.app.dto.user.UserForm
import st.cri.app.exception.DoesNotExistException
import st.cri.app.factory.UserFactory
import st.cri.app.security.CurrentSession
import st.cri.app.service.UserService
import st.cri.app.template.dto.Selector
import st.cri.app.template.service_impl.TemplateServiceImpl
import st.cri.app.template.view.ViewEntity
import st.cri.app.utils.URLBuilder
import java.util.*
import java.util.regex.Pattern

@Service
class UserServiceImpl(
    private val userDao: UserDao, private val userFactory: UserFactory, private val urlBuilder: URLBuilder,
    val passwordEncoder: PasswordEncoder, val currentSession: CurrentSession
) : TemplateServiceImpl<User, UserDTO, UserForm, UserFactory>(), UserService {

    @Throws(UnsupportedOperationException::class)
    override fun fieldValueNotExistOther(value: ViewEntity?, fieldName: String): Boolean {
        if (fieldName != null && value != null) {
            val form: UserForm? = value as UserForm?
            if (fieldName == "email") {
                val emailRegexPattern = "^(.+)@(\\S+)$"
                if (!Pattern.compile(emailRegexPattern)
                        .matcher((value as UserForm?)?.email ?: throw UnsupportedOperationException("El email no es válido"))
                        .matches()
                ) {
                    throw UnsupportedOperationException("El email no es válido")
                }
            }
            //	        if (!fieldName.equals("username")) {
//	            throw new UnsupportedOperationException("No existe implementacion para el campo "+ fieldName);
//	        }
            logger.trace("Valido que no exista el username {}", value)
            val op: User? = userDao.findByUsername(form!!.email!!)
            return if (op != null && form.validateAsEdition()) {
                //Chequeo si es el mismo es valido
                op.id!!.equals(form.id)
            } else false
        }
        return false
    }

    @Transactional
    override fun create(form: UserForm): User {
        val newUser: User = super.create(form) as User
        //		String password = RandomStringUtils.randomAlphanumeric(8);
        newUser.activate(form.password!!, passwordEncoder)
        logger.trace("Se activo el usuario: {}", newUser.getUsername())
        //		mailService.sendRegistrationMailAutogeneratedPass(newUser.getCompanyName(), newUser.getEmail(),
//				password);
        return newUser
    }

    override fun update(id: Long, form: UserForm): Any {
        return super.update(id, form)
    }

    override fun delete(id: Long) {
        super.delete(id)
    }

    override fun deactivate(id: Long) {
        super.deactivate(id)
    }

    override fun activate(id: Long) {
        super.activate(id)
    }

    override fun fieldValueExists(value: Any, fieldName: String): Boolean {
        TODO("Not yet implemented")
    }

    @Transactional
    fun createWithLink(form: UserForm?): User {
        val newUser: User = super.create(form!!)
        val link: String = urlBuilder.offlineAbsoluteActiveAccountPathLink(newUser.activationToken!!)
//        mailService.sendRegistrationMail(newUser.getUsername(), newUser.getEmail(), link)
        return newUser
    }

    @Transactional
    override fun delete(id: Long?) {
        val user: User = userDao.findById(id!!).orElseThrow { DoesNotExistException(USER_NOT_FOUND_MSG) }
        user.deactivate()
        logger.trace("Se desactivo el usuario: {}", user.getUsername())
    }

    @Transactional
    override fun activate(id: Long?) {
        val user: User = userDao.findById(id!!).orElseThrow { DoesNotExistException(USER_NOT_FOUND_MSG) }
        user.activate()
        logger.trace("Se activa el usuario: {}", user.getUsername())
    }

    @Transactional
    override fun deactivate(id: Long?) {
        val user: User = userDao.findById(id!!).orElseThrow { DoesNotExistException(USER_NOT_FOUND_MSG) }
        user.deactivate()
        logger.trace("Se desactiva el usuario: {}", user.getUsername())
    }

    /**
     * Activacion de cuenta y contraseña
     */
    @Transactional
    override fun activateUserAccount(token: String, password: String): RoleName {
        val user: User = userDao.findByActivationToken(token) ?: throw DoesNotExistException("El acceso ha expirado")
        user.activate(password, passwordEncoder)
        logger.trace("Se activo el usuario: {}", user.getUsername())
        return user.role.name
    }

    @Transactional
    override fun resetUserPassword(username: String) {
        val op: User = userDao.findByUsername(username) ?: throw DoesNotExistException("El usuario no existe")
        val user: User = op
        user.resetPassword()
        logger.trace("Se generó token para resetear contraseña del user: {}", username)
//        val link: String = urlBuilder.offlineAbsoluteActiveAccountPathLink(user.getActivationToken()!!)
//        mailService.sendResetPasswordMail(user.getUsername(), user.getEmail(), link)
        logger.trace("Se envio reset de pass para el usuario: {}", user.getUsername())
    }

    override val currentUserInSession: UserDTO
        /**
         * Filtro de busqueda en la pagina de usuarios
         */
        get() = Optional.of(currentSession.user!!).map(userFactory::assemble).orElse(null)

    override fun getAll(filter: UserForm, pageable: PageRequest?): Page<UserDTO> {
        return super.getAll(filter, pageable!!)
    }

    override fun getSelectorList(filter: UserForm): List<Selector> {
        return super.getSelectorList(filter)
    }

    override fun getFormById(id: Long): Optional<UserForm> {
        return super.getFormById(id)
    }

    override fun findById(id: Long): Optional<UserDTO> {
        return super.findById(id)
    }

    companion object {
        private val logger = LogManager.getLogger(
            UserServiceImpl::class.java
        )
        private const val USER_NOT_FOUND_MSG = "No existe el usuario"
    }
}
